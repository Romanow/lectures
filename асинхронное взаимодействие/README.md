# Асинхронное взаимодейтсвие

## Масштабирование

Существует два принципиальных вида масштабирования – вертикальное и горизонтальное.

#### Вертикальное

Вертикальное масштабирование заключается в увеличении производительности системы за счет увеличения мощности сервера. По
сути, при вертикальном масштабировании задача увеличения производительности отдается на outsource производителям железа.
Специалисты, которые делают большую железку, предлагают некое обобщенное решение, которое будет работать быстрее. Вы
заменили машину — и у вас стало работать быстрее. Один из главных недостатков — вертикальное масштабирование ограничено
определенным пределом. Параметры железа нельзя увеличивать бесконечно. В какой-то момент станет нужна уже тысяча
серверов. Закупить столько железа будет либо невозможно, либо нецелесообразно. Кроме того, стоимость машин с более
высокими характеристиками не обязательно возрастает линейно. Следующая по мощности машина может стоить уже даже не в
два раза дороже, чем предыдущая. Поэтому вертикальное масштабирование требует крайне аккуратного планирования.

#### Горизонтальное

Основной его принцип горизонтального масштабирования — мы подключаем дополнительные серверы, хранилища и учим нашу
программную систему использовать их все. Именно горизонтальное масштабирование является сейчас фактически стандартом.

При использовании вертикального и горизонтально масштабирования мы все равно рано или поздно столкнемся с проблемой, что
сервера ставить больше некуда. Таким образом, нам придется пересмотреть наш подход с полностью синхронной обработкой
данных, т.е. внимательно изучить предметную область, как данные движутся внутри системы, как они обрабатываются, откуда
и куда текут, и решить, какие из действий с данными можно отложить на потом. Некоторые данные всегда должны быть
актуальными, а при обновлении других можно изменения отображать не сразу.

Пользователь, который постит сообщение в свой блог, должен тут же увидеть это сообщение, иначе он подумает, что что-то
сломалось. А во френд-ленте друзей пользователя это сообщение может появиться и через минуту. Зная такие особенности,
можно применять прекрасный метод, который называют отложенной обработкой. Его суть заключается в том, что данные
обрабатываются в тот момент, когда это наиболее удобно. Например, для обработки статистики мы можем сделать cron,
который буде проводить все вычисления в момент времени, когда нагрузка минимальная - т.е. по ночам.

## Синхронный и Асинхронный подходы

Все модели коммуникации в распределенных системах можно разделить на две группы:

* синхронная обработка – клиент сделал запрос и ожидает ответ;
* асинхронная – коммуникация выполняется.

### Синхронная обработка

| Проблемы | Решения |
|----------|---------|
| Нет гарантии, что ответ от сервера будет всегда быстрым, т.е. нужно предусматривать таймауты | Скорость ответа – устанавливается таймаут запроса, обычно он равен 2 * 95% line |
| Клиент и сервер должны быть активны в момент вызова | Использование Service Discovery, которое имеет актуальную инфомрацию о доступности сервиса. Так же использовать бесшовный деплой |
| Если сервер не смог с первого раза обработать запрос (был недоступен, таймаут и т.п.), то ответственность за повтор запроса лежит на клиенте | В случае если запрос завершился timeout’ом, то этот запрос можно выполнить еще раз, при этом нужно помнить про идемпотентность запросов |
| Пиковая нагрузка может привести к недоступности всей системы | Пиковая нагрузка не происходит внезапно, обычно это какие-то прогнозируемые события (например, черная пятница в интернет магазине), а значит к ним можно подготовиться и масштабировать приложение на несколько дополнительных машин |

В большинстве случаев для реализации синхронного взаимодействия используется протокол прикладного уровня HTTP и набор
архитектурных соглашений под названием REST (Representational State Transfer). Возьмем его за основу.

При этом синхронный подход дает ряд существенных преимуществ, которые очень сильно упрощают разработку:

* простота реализации – т.к. используется протокол HTTP как транспорт, большинство проблем:
    * шифрование;
    * согласование типов представления (content negotiation);
    * балансировка – уже решена и эти решения достаточно просты в применении;
* предсказуемая скорость ответа – мы знаем что система когда-нибудь ответит или произойдет ошибка соединения;
* прозрачность – если сервер не смог обработать сообщение, клиент сразу узнает об этом.

### Асинхронная обработка

Асинхронная обработка характеризуется тем, что запрос и ответ разнесены по времени. Существует целый класс однотипных
задач, для которых принципиально порядок обработки. Для подобных целей используют инструмент, называемый очередями.
Очередь — абстрактный тип данных с дисциплиной доступа к элементам "первый пришёл — первый вышел" (FIFO, First In —
First Out). Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный
элемент из очереди удаляется.

Использование очередей позволяет сделать систему более устойчивой к сбоям. Если операция завершилась неудачно, запрос на
её выполнение можно вернуть в очередь и направить на обработку на другого worker’а. Также очередь сообщений позволяет
функционально развязать куски системы и дает возможность кому-то временно сломаться без общей деградации. Если один
компонент системы хочет послать сообщение другому компоненту, он посылает данное сообщение в очередь, а очередь уже
самостоятельно пересылает его адресату. Таким образом, приложение, пославшее сообщение, не должно ждать ответа, и может
продолжать свою текущую деятельность. Ни приложение, посылающее сообщение, ни адресат данного сообщения не обязаны быть
активными в одно и то же время. Работа с очередями выполняется с помощью специального приложения – Брокера Очередей.

В очередях есть важное понятие _Backpressure_ – очередь предоставляет лишь набор данных для обработки, клиент сам
запрашивает порцию данных когда он становится свободен.

Компоненты системы не связаны напрямую друг с другом (decoupled), а потому возможно перенесение компонентов с одного
хоста на другой в runtime без ущерба для работоспособности системы.

Введем некоторые определения:

* Topic – это название категории в котором сообщения публикуются производителями сообщений;
* Broker - некоторый сервер, выполняющий функции очереди.

Существует две основных модели обмена сообщениями:

* Point-to-Point – эта модель применяется, когда одному или нескольким компонентам (senders) необходимо послать
  сообщение одному компоненту-адресату (receiver). Для промежуточного хранения данных используется очередь. В общем
  случае в модели Point-to-Point может несколько отправителей и несколько приемщиков сообщений, но брокер доставит
  сообщение только одному.
* Publisher-Subscriber – эта модель применима, когда одному или нескольким компонентам (publishers) необходимо послать
  сообщение одному или нескольким компонентам-адресатам (subscribers). Данная модель основана на понятии message topic.
  Publishers посылают сообщения в topic, и все subscribers данного topic получают эти сообщения.

Т.к. асинхронная обработка снимает необходимость ответить клиенту сразу, мы получаем ряд важных свойств такой системы:
сервер может быть недоступен в момент запроса; система легко масштабируется, для увеличения пропускной способности
достаточно просто добавить новых обработчиков, брокер сам начнет присылать им задания; если возрастает нагрузка, то
система не захлебнется запросами, т.к. есть backpressure.

Несмотря на все плюсы асинхронной обработки, она очень сложна в реализации. Вот краткий список основных трудностей,
связанных с реализацией такого подхода:

* клиент и сервер должны гарантировать доставку и успешную обработку сообщений;
* каждый запрос становится заявкой и должен иметь персистентное состояние, чтобы гарантировать нахождение системы всегда
  в детерминированном положении. такую систему сложно мониторить, т.к. недоступность или ошибка в системе может
  выливаться лишь в увеличении очереди;
* система не прозрачна с точки зрения бизнес-процессов, т.к. синхронные процессы разрываются на асинхронные независимые
  этапы. Ее очень сложно проектировать и расширять.

#### Виды асинхронной обработки

Часто помимо обработки самого запроса требуется сделать много дополнительных вещей, связанных с самим запросом лишь
косвенно: запись статистики, инкременты счетчиков. Эти операции можно выполнить на этапе постобработки после того, как
ответ был отдан пользователю. Однако иногда описанного выше подхода с постобработкой данных недостаточно. Действия,
которые надо совершить с ними, могут занимать слишком много времени, а ресурсы веб-сервера не безграничные. В таком
случае помогает следующий архитектурный паттерн — сохраните данные в некое промежуточное хранилище, а затем обработайте
их с помощью отдельного асинхронного процесса. То есть данные собираются сейчас, а обрабатываются тогда, когда будет
удобно.

Примеры:

* Отложенная обработка: отправка письма о завершении регистрации в фоновом потоке.
* Фоновый процесс: отправка предагегированных данных в сервис статистики раз в час.

### Заявка, жизненный цикл заявки

Ввиду того, что в рамках распределенных систем мы взаимодействуем с другими системами, находящимися вне нашего контроля,
при проектировании следует предусматривать обработку отказов и некорректных состояний.

Введем понятие заявки как некоторой единицы работы, передаваемой для выполнения ко внешней системе. С каждой заявкой
обычно ассоциируется некоторый уникальный ID, служащий для ее идентификации как в системе-инициаторе, так и во внешней
системе. Это может быть либо один и тот же идентификатор, сообщаемый системе-инициатору заявки после принятия заявки на
обработку. Но это могут быть и два разных идентификатора: один создаётся в системе, обрабатывающей заявку, а другой
создается в системе обработчике. Наличие в пришедшем сообщении на создание заявки идентификатора заявки, назначенного
удалённой системой, крайне полезно, поскольку позволяет отбросить дубликаты таких сообщений.

Т.к. заявка является единицей работы, у нее должны быть начальное и конечные состояния. Под обработкой заявки
подразумеваем переход заявки из начального состояние в какое-то конечное (
успешное/неуспешное). После попадания в конечное состояние заявка уже не меняет свое состояние, а находится в некотором
архиве завершенных заявок.

Кроме основного состояния, заявка обычно характеризуется множеством параметров, которые можно разбить на две группы.

* К первой относятся полученные извне параметры заявки, появляющимися в момент её создания из параметров сообщения, и,
  может быть, меняемые в дальнейшем. Эту группу мы будем (условно) называть параметрами запроса.
* Ко второй группе относятся добавленные в ходе выполнения заявки параметры, связанные с процессом обработки заявки. Это
  множество может меняться в процессе жизни заявки. Эту группу мы будем (условно) называть параметрами обработки заявки.

Очевидно, что создание протокола, допускающего произвольное изменение параметров запроса извне может быть довольно
сложным, особенно если речь идёт о запросе дополнительных ресурсов или частичном уменьшении требуемых ресурсов (
представим, что в ходе обработки заявки мы закупаем недостающий товар у третьего лица). Поэтому в реальных системах мы
часто видим ситуацию, когда единственным допустимым изменением со стороны является запрос на отмену заявки, а для
добавление ресурсов нужно послать запрос на создание новой заявки.

Естественным представлением жизненного цикла заявки является детерминированный конечный автомат с выходом. Формально
было бы верно считать множеством состояний этого автомата подмножество декартова произведения множества состояний заявки
и всех множеств значений параметров обработки заявки. Однако практическая полезность у такого автомата может быть только
при использовании формальных методов его исследования, для программиста же весьма сомнительна полезность автомата, где
каждая из N попыток повтора опроса M идентичных (с точки зрения уровня протокола) систем представлена отдельным
состоянием. В силу этого, при проектировании используется сокращённый вид автомата, где явно отображаются только
основные состояния заявки, в то время как состояние автомата определяется, формально, как подмножество декартово
произведения состояния и параметров. Функция перехода будет отображать состояние заявки, параметры заявки и сообщение (
со всеми его параметрами) в новое состояние заявки и в новые параметры заявки (например, число неудавшихся попыток
увеличилось на единицу). Состояния автомата соответствуют моментам времени, в котором он ожидает получения сообщений (от
внешних систем, подтверждения от человека и т.д.).

В соответствии с данным определением РС, автомат должен отвечать как минимум двум требованиям:

* при получении любого сообщения, на появление которого не удалось придумать сколь-нибудь разумную реакцию в данном
  состоянии, автомат либо остается в данном состоянии (и добавляет запись в журнал для дальнейшего разбора), либо
  переходит в конечное состояние;
* автомат должен попадать в одно из конечных состояний за конечный промежуток времени при любой входной цепочке внешних
  событий.

Таким образом, при каждой смене состояния должен запускаться (или продолжать работать) таймер, который пришлет сообщение
о таймауте, которое должно быть обработано автоматом.

Отметим, что успешная отправка сообщения в РС не означает, что сообщение принято к исполнению, поэтому нет оснований
утверждать, что мы когда-нибудь получим ответ. Поэтому, в силу требования надежности, использование таймеров необходимо
всегда.

## Отказоустойчивость

Самые сложные ошибки в распредленных системах связаны с рассинхронизацией данных. Приложение должно быть написано таким
образом, чтобы при некорректной обработке сообщения, система оставалсь в детерминированном состоянии. Для этого нужно _
всегда_ предусматривать обработку некорректных ситуаций.

### Потеря сообщений

Часто при разговоре про взаимодействие через очереди говорят что "очередь дает гарантию доставки сообщений". Рассмотрим
этот вопрос подробнее.

Сообщения могут теряться потому что:

* не включен persistence на брокере;
* нет транзакционности на стороне отправителя и получателя;
* нет ожидания ACK на стороне отправителя;
* AUTO ACK на стороне получателя;
* запись на диск на брокере буферизуются, т.е. при отключении питания на брокере сообщения, хранящиеся в буфере,
  потеряются.

##### Потеря сообщений на Producer

Если данные передаются по UDP или обрывается TCP соединение, то клиент должен ожидать подтверждение получения от брокера
и переотправлять сообщения, если это подтверждение не пришло.

##### Потеря сообщений на Broker

* Если на брокере не включена persistence, то при падении ноды данные теряются.
* Если persistence включена, то писать каждое сообщение на диск очень затратно, поэтому используется буферизованная
  запись на диск, а значит при падении, эти данные из буфера потеряются.
* Обычно на боевых серверах разворачивается кластер в несколько нод и используется репликация. Здесь можно выбрать три
  политики согласования:
    * At Least One – хотя бы одна из реплик подтвердила запись;
    * Quorum – большинство реплик записало данные;
    * All – все реплики записали данные.
* В случае с брокером, развернутом на несколько нод, если отдавать подтверждение когда все сервера в реплике получили
  свои данные, то это очень затратно по времени, если это делать в фоне, то данные, которые не успели реплицироваться,
  теряются.

##### Потеря сообщений на Consumer

* Если данные передаются по UDP или обрывается TCP соединение, то на брокере должен ожидать подтверждение доставки и
  переотправлять сообщения, если это подтверждение не пришло.
* Если потеряется подтверждление, то броке через какое-то время перенаправит это сообщение другому Consumer’у, а значит
  Consumer должна быть реализован так, чтобы не обрабатывать дубли, или обрабатывать их идемпотентно.
* Consumer сразу отдает ACK, то при ошибке обработки или падении сервера, данные потеряются. Но если Consumer ждет
  окончания обработки, то это сильно тормозит брокера.

### Дубликаты сообщений

Для предотвращения дважды отправленных сообщений на producer’е добавляется уникальный ID в Message Header. Этот
заголовок читается на брокере, и он отфильтровывает дубликаты (если включена политика поиска дубликатов). Consumer
должен отправить ACK на провайдер когда получил сообщение (сообщение может оказаться битым, т.к. мы уже ответили брокеру
что все ОК, мы его не получим), либо отвечать ACK только когда сообщение обработалось. Это очень сильно снижает
производительность. Так же в момент отправки ACK сеть может упасть и брокер не получив информацию отправит сообщение еще
раз, и если сообщение не содержит никакого уникального идентификатора, то мы не сможем с уверенностью сказать что именно
это сообщение было уже обработано.

### Деградация функциональности

Если у нас есть запрос на чтение, то в случае недоступности некритичной части системы, мы можем отдавать пользователю
ответ не со всем набором данных.

Например, если мы открываем главную страницу `mail.ru` для проверки почты, то нам важно, чтобы виджет почты показал нам
количество новых сообщений. При этом на самой странице есть еще много дополнительной информации, например виджет погоды,
и если сервис, который отдает данные для этого виджета недоступен в данный момент времени, то мы просто не будем
выводить его или отдадим устаревшие закешированные данные. Для большинства пользователей это будет незаметно.

Если же мы из-за недоступности отдадим страницу с 500 ошибкой, то это заметят все пользователи и посещаемость нашей
страницы упадет.

Деградацию функциональности можно реализовать тремя разными путями:

* отдаем просто пустой ответ и ничего не выводим;
* отдаем какой-то fallback ответ или просто выводим ID по которому нужно было получить информацию (например, если нам
  надо получить ФИО пользователя по его login);
* отдаем закешированные устаревшие данные (как с виджетом погоды).

### Некорректное выполнение операций

Если мы рассматриваем микросервисную архитектуру, то система разбита на независимые сервисы, а каждый сервис имеет свое
независимое хранилище данных, то нам надо гарантировать консистентность данных в случае, если какая часть операций
завершилась неудачно.

Предположим, у нас есть система, позволяющая продавать какие-то позиции (биллнг) и в автоматическом режиме передающая
данные в складскую систему, для начала немедленной отгрузки товара. Понятно, что выполнять отгрузку товара можно
начинать только после успешной оплаты. И этот вариант мы можем легко предусмотреть, дожидаясь успешного завершения
обработки от билингвой системы.

Но что делать, если оплата прошла успешно, а обработка в складской системе завершилась неудачей?

#### Повторная попытка

Самый просто способ в этой ситуации – перенести заявку в очередь и выполнить операцию еще раз через какое-то время, а
сервису, инициировавшему запрос вернуть ответ, что все хорошо. Для некоторых видов операций в этом есть определенный
смысл, но мы должны гарантировать, что повторная попытка исправит ситуацию. Вместо использования транзакционной границы
как гарантии согласованного состояния по окончании транзакции мы допускаем, что система сама приведет себя в
согласованное состояние в какой-то будущий момент времени.

#### Отмена всей операции

Еще один вариант заключается в отмене всей операции. В этом случае систему нужно вернуть в прежнее согласованное
состояние. Необходимое действие выполняется в рамках компенсационной транзакции, то есть запуска новой транзакции для
отката всего, что только что случилось. В нашем случае все может свестись к простой выдаче инструкции удаления DELETE,
предназначенной для удаления заказа из базы данных. Затем нужно будет отчитаться в пользовательском интерфейсе о сбое
операции. В монолитной системе наше приложение может справиться с обоими аспектами, а вот когда код приложения уже
разбит на части, нужно призадуматься о том, что делать. Где именно должна находиться логика управления компенсационной
транзакцией, в клиентском сервисе или где-то еще? А как быть, если произойдет сбой компенсационной транзакции?
Вероятность этого не исключена. Тогда у нас будет оплаченный заказ, не имеющий соответствующей ему инструкции по
сборке. В такой ситуации нужно либо провести компенсационную транзакцию повторно, либо позволить какому-нибудь
внутреннему процессу убрать несогласованность чуть позже. Можно было бы просто воспользоваться экраном обслуживания с
доступом только со стороны административного персонала или же использовать автоматизированный процесс. Все становится
намного запутаннее, когда требуется выполнить согласованность более двух операций. Проведение компенсационных
транзакций для каждого сбойного режима очень трудно не то что реализовать, но даже осмыслить.

#### Распределенные транзакции

Альтернативой ручной организации компенсационных транзакций является использование распределенной транзакции.
Распределенные транзакции пытаются объединить в себе сразу несколько транзакций, используя для управления различными
транзакциями, проводимыми в базовых системах, общий управляющий процесс, называемый диспетчером транзакций. Точно
так же, как и обычная транзакция, распределенная транзакция старается гарантировать пребывание всего в согласованном
состоянии, только она пытается сделать это в рамках нескольких систем, запущенных в различных процессах, связь между
которыми зачастую осуществляется через сетевые границы. Наиболее распространенный алгоритм управления распределенными
транзакциями заключается в использовании двухфазной фиксации.

Двухфазный commit имеет два четко разделенных этапа:

* **Commit Request** – координатор посылает сообщение участникам распределенной транзакции о подготовке к транзакции (
  prepare message). Это сообщение также содержит уникальный номер транзакции TID. Когда участники получают это
  сообщение, они проверяют смогут ли зафиксировать транзакцию и отвечают координатору. При этом транзакция исполняется,
  но не фиксируется и её состояние сохраняется на диске;
* **Commit Completion** - после того, как координатор получил все ответы, он решает зафиксировать или прервать начатую
  транзакцию в соответствии с правилом глобальной фиксации. Если все участники глобальной транзакции ответили, что могут
  ее зафиксировать, то он посылает участникам сообщение о фиксации транзакции, в противном случае все участники получают
  сообщение об откате транзакции.

Такой подход предполагает, что все участники останавливаются, пока центральный координационный процесс не даст
команду на продолжение работы. Если диспетчер транзакций зависнет, отложенные транзакции никогда не завершатся. Если
сервис не ответит в процессе голосования, все будет заблокировано. И неизвестно, что произойдет, если фиксация даст
сбой после голосования. В этом алгоритме есть безусловное предположение о том, что такого никогда не случится: если
партнер сказал "да» при голосовании, значит, мы должны предполагать, что его транзакция будет зафиксирована. Партнерам
нужен способ, позволяющий заставить фиксацию происходить в нужный момент. Это означает, что данный алгоритм не
защищен от сторонних сбоев, вернее, он предусматривает попытку обнаружения большинства случаев сбоев. Этот
координационный процесс предусматривает также установку блокировок, то есть отложенная транзакция должна удерживать
блокировку ресурсов.

Блокировка ресурсов может привести к конкуренции, существенно усложняя масштабируемые системы, особенно в контексте
распределенных систем. Все эти решения усложняют систему. Разобраться в распределенных транзакциях довольно трудно и
фактически они могут воспрепятствовать масштабированию. О системах, которые в конечном итоге сводятся к компенсационной
логике повторов, труднее рассуждать, и для устранения несогласованности данных они могут нуждаться в ином
компенсационном поведении. Когда вам встречаются бизнес-операции, проводимые в данный момент в рамках единой
транзакции, задайте себе вопрос, действительно ли они должны это делать. Не могут ли они проводиться в различных
локальных транзакциях и полагаться на концепцию возможной согласованности? Создавать такие системы и заниматься их
масштабированием намного проще. Если попадется такое состояние, необходимость в согласованности которого не вызывает
никаких сомнений, то в первую очередь сделайте все возможное, чтобы избежать разбиения. Приложите для этого все
усилия. Если же разбиения будет не избежать, подумайте об изменении чисто технического взгляда на процесс и создайте
конкретные понятия, представляющие саму транзакцию. Это даст вам возможность зацепиться за запуск других операций,
подобных компенсационным. транзакциям, а также за способ отслеживания этих более сложных понятий в вашей системе и
управления ими.

## Event-Driven Architecture

В очередь публикуется событие об изменении состояния какого-либо сервиса, все заинтересованные сервисы слушают это
событие и выполняют внутренние действия, связанные с этим событием. Возможно, они могут порождать новые события,
переводящие всю систему в следующее состояние. Это очень гибкий архитектурный паттерн, но т.к. события не всегда 1:1
ложатся на бизнес процесс, этот бизнес-процесс становится неявно размазанным по нескольким сервисам. Плюс к этому,
компенсационные операции становится проводить еще сложнее, т.к. системы настолько изолированы друг от друга, что откат
некорректной операции можно проводить только с помощью создания отдельных событий.

#### Когда следует использовать этот подход

* для обработки одних и тех же событий несколькими подсистемами;
* для обработки в режиме реального времени, с минимальными задержками;
* для обработки сложных событий, например сопоставления шаблонов или статистической обработки за некоторый период;
* при больших объемах и скоростях поступления данных.

#### Преимущества

* отправители и получатели независимы друг от друга;
* нет интеграции "point - point", легко добавлять в систему новые объекты-получатели;
* получатели могут реагировать на события сразу при их поступлении;
* высокая масштабируемость и распределение;
* подсистемы получают независимые представления потока событий.

#### Сложности

* гарантированная доставка: в некоторых системах важно гарантировать доставку событий;
* обработка событий в строгом порядке и (или) строго один раз: каждый тип потребителя обычно выполняется на нескольких
  экземплярах, чтобы обеспечить надежность и масштабируемость. Это создает некоторые трудности, если события должны
  обрабатываться в строгом порядке (для каждого типа потребителя) или логика их обработки не является идемпотентной.

## Очереди

## Теорема CAP

## Протоколы распределенных систем

### Протокол RAFT

### Протокол Gossip

## Примеры

Для демонстрации развернем кластер из 2 брокеров Kafka и Zookeeper.

```shell
$ git clone git@github.com:Romanow/ansible-kafka.git
$ cd ansible-kafka
```

#### Локальный кластер

```shell
$ cd vagrant
$ vagrant up
$ vagrant status
Current machine states:

zookeeper                 running (virtualbox)
broker1                   running (virtualbox)
broker2                   running (virtualbox)

$ sudo tee -a /etc/hosts > /dev/null << EOT
192.168.51.10     zookeeper.romanow-alex.ru
192.168.51.11     broker-1.romanow-alex.ru
192.168.51.12     broker-2.romanow-alex.ru
EOT

$ ansible-playbook -i inventories/local/static.yml --vault-password-file=.vault_pass kafka.yml -v

PLAY RECAP ***********************************************************************************************************************
192.168.51.10              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
192.168.51.11              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
192.168.51.12              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

#### Кластер в DigitalOcean

```shell
$ cd terraform
$ terraform apply
Apply complete! Resources: 6 added, 0 changed, 0 destroyed.

Outputs:

instance_ip_addr = [
  "161.35.86.193",
  "161.35.86.247",
  "161.35.86.216",
]

$ export DO_API_TOKEN=<DigitalOcean Token>
$ ansible-playbook -i inventories/digitalocean/digital_ocean.py --vault-password-file=.vault_pass kafka.yml -v

PLAY RECAP ***********************************************************************************************************************
161.35.86.193              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
161.35.86.216              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
161.35.86.247              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

Работа с Kafka через консольные утилиты:

```shell
$ wget https://archive.apache.org/dist/kafka/2.8.1/kafka_2.12-2.8.1.tgz -O kafka.tgz
$ mkdir kafka && tar zxvf kafka.tgz -C kafka --strip-components 1
$ cd kafka
$ ./kafka-topics.sh --zookeeper zookeeper.romanow-alex.ru:2181 --create --replication-factor 1 --partitions 1 --topic TestTopic
Created topic TestTopic.
$ ./kafka-topics.sh --list --zookeeper zookeeper.romanow-alex.ru:2181
TestTopic
# Из разных терминалов
$ ./kafka-console-producer.sh --bootstrap-server broker-1.romanow-alex.ru:9092,broker-2.romanow-alex.ru:9092 --topic TestTopic
>Hello, world
>Welcome to microservices
>Kafka is the best broker!

$ ./kafka-console-consumer.sh --bootstrap-server broker-1.romanow-alex.ru:9092,broker-2.romanow-alex.ru:9092 --topic TestTopic
Hello, world
Welcome to microservices
Kafka is the best broker!
^CProcessed a total of 3 messages
```

## Литература

1. [Backpressure explained — the resisted flow of data through software](https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7)
1. [Нужен ли нам JMS в мире современных Java-технологий](https://www.youtube.com/watch?v=ExjPxDxkmFo)
1. [Оркестрируемая сага или как построить бизнес-транзакции в сервисах с паттерном database per service](https://habr.com/ru/company/oleg-bunin/blog/418235/)
1. [Microservices — When to React Vs. Orchestrate](https://medium.com/capital-one-tech/microservices-when-to-react-vs-orchestrate-c6b18308a14c)