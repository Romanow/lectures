# Асинхронное взаимодейтсвие

## Масштабирование

Существует два принципиальных вида масштабирования – вертикальное и горизонтальное.

#### Вертикальное

Вертикальное масштабирование заключается в увеличении производительности системы за счет увеличения мощности сервера. По
сути, при вертикальном масштабировании задача увеличения производительности отдается на outsource производителям железа.
Специалисты, которые делают большую железку, предлагают некое обобщенное решение, которое будет работать быстрее. Вы
заменили машину — и у вас стало работать быстрее. Один из главных недостатков — вертикальное масштабирование ограничено
определенным пределом. Параметры железа нельзя увеличивать бесконечно. В какой-то момент станет нужна уже тысяча
серверов. Закупить столько железа будет либо невозможно, либо нецелесообразно. Кроме того, стоимость машин с более
высокими характеристиками не обязательно возрастает линейно. Следующая по мощности машина может стоить уже даже не в
два раза дороже, чем предыдущая. Поэтому вертикальное масштабирование требует крайне аккуратного планирования.

#### Горизонтальное

Основной его принцип горизонтального масштабирования — мы подключаем дополнительные серверы, хранилища и учим нашу
программную систему использовать их все. Именно горизонтальное масштабирование является сейчас фактически стандартом.

При использовании вертикального и горизонтально масштабирования мы все равно рано или поздно столкнемся с проблемой, что
сервера ставить больше некуда. Таким образом, нам придется пересмотреть наш подход с полностью синхронной обработкой
данных, т.е. внимательно изучить предметную область, как данные движутся внутри системы, как они обрабатываются, откуда
и куда текут, и решить, какие из действий с данными можно отложить на потом. Некоторые данные всегда должны быть
актуальными, а при обновлении других можно изменения отображать не сразу.

Пользователь, который постит сообщение в свой блог, должен тут же увидеть это сообщение, иначе он подумает, что что-то
сломалось. А во френд-ленте друзей пользователя это сообщение может появиться и через минуту. Зная такие особенности,
можно применять прекрасный метод, который называют отложенной обработкой. Его суть заключается в том, что данные
обрабатываются в тот момент, когда это наиболее удобно. Например, для обработки статистики мы можем сделать cron,
который буде проводить все вычисления в момент времени, когда нагрузка минимальная - т.е. по ночам.

## Синхронный и Асинхронный подходы

Все модели коммуникации в распределенных системах можно разделить на две группы:

* синхронная обработка – клиент сделал запрос и ожидает ответ;
* асинхронная – коммуникация выполняется.

### Синхронная обработка

| Проблемы | Решения |
|----------|---------|
| Нет гарантии, что ответ от сервера будет всегда быстрым, т.е. нужно предусматривать таймауты | Скорость ответа – устанавливается таймаут запроса, обычно он равен 2 * 95% line |
| Клиент и сервер должны быть активны в момент вызова | Использование Service Discovery, которое имеет актуальную инфомрацию о доступности сервиса. Так же использовать бесшовный деплой |
| Если сервер не смог с первого раза обработать запрос (был недоступен, таймаут и т.п.), то ответственность за повтор запроса лежит на клиенте | В случае если запрос завершился timeout’ом, то этот запрос можно выполнить еще раз, при этом нужно помнить про идемпотентность запросов |
| Пиковая нагрузка может привести к недоступности всей системы | Пиковая нагрузка не происходит внезапно, обычно это какие-то прогнозируемые события (например, черная пятница в интернет магазине), а значит к ним можно подготовиться и масштабировать приложение на несколько дополнительных машин |

В большинстве случаев для реализации синхронного взаимодействия используется протокол прикладного уровня HTTP и набор
архитектурных соглашений под названием REST (Representational State Transfer). Возьмем его за основу.

При этом синхронный подход дает ряд существенных преимуществ, которые очень сильно упрощают разработку:

* простота реализации – т.к. используется протокол HTTP как транспорт, большинство проблем:
    * шифрование;
    * согласование типов представления (content negotiation);
    * балансировка – уже решена и эти решения достаточно просты в применении;
* предсказуемая скорость ответа – мы знаем что система когда-нибудь ответит или произойдет ошибка соединения;
* прозрачность – если сервер не смог обработать сообщение, клиент сразу узнает об этом.

### Асинхронная обработка

Асинхронная обработка характеризуется тем, что запрос и ответ разнесены по времени. Существует целый класс однотипных
задач, для которых принципиально порядок обработки. Для подобных целей используют инструмент, называемый очередями.
Очередь — абстрактный тип данных с дисциплиной доступа к элементам "первый пришёл — первый вышел" (FIFO, First In —
First Out). Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный
элемент из очереди удаляется.

Использование очередей позволяет сделать систему более устойчивой к сбоям. Если операция завершилась неудачно, запрос на
её выполнение можно вернуть в очередь и направить на обработку на другого worker’а. Также очередь сообщений позволяет
функционально развязать куски системы и дает возможность кому-то временно сломаться без общей деградации. Если один
компонент системы хочет послать сообщение другому компоненту, он посылает данное сообщение в очередь, а очередь уже
самостоятельно пересылает его адресату. Таким образом, приложение, пославшее сообщение, не должно ждать ответа, и может
продолжать свою текущую деятельность. Ни приложение, посылающее сообщение, ни адресат данного сообщения не обязаны быть
активными в одно и то же время. Работа с очередями выполняется с помощью специального приложения – Брокера Очередей.

В очередях есть важное понятие _Backpressure_ – очередь предоставляет лишь набор данных для обработки, клиент сам
запрашивает порцию данных когда он становится свободен.

Компоненты системы не связаны напрямую друг с другом (decoupled), а потому возможно перенесение компонентов с одного
хоста на другой в runtime без ущерба для работоспособности системы.

Введем некоторые определения:

* Topic – это название категории в котором сообщения публикуются производителями сообщений;
* Broker - некоторый сервер, выполняющий функции очереди.

Существует две основных модели обмена сообщениями:

* Point-to-Point – эта модель применяется, когда одному или нескольким компонентам (senders) необходимо послать
  сообщение одному компоненту-адресату (receiver). Для промежуточного хранения данных используется очередь. В общем
  случае в модели Point-to-Point может несколько отправителей и несколько приемщиков сообщений, но брокер доставит
  сообщение только одному.
* Publisher-Subscriber – эта модель применима, когда одному или нескольким компонентам (publishers) необходимо послать
  сообщение одному или нескольким компонентам-адресатам (subscribers). Данная модель основана на понятии message topic.
  Publishers посылают сообщения в topic, и все subscribers данного topic получают эти сообщения.

Т.к. асинхронная обработка снимает необходимость ответить клиенту сразу, мы получаем ряд важных свойств такой системы:
сервер может быть недоступен в момент запроса; система легко масштабируется, для увеличения пропускной способности
достаточно просто добавить новых обработчиков, брокер сам начнет присылать им задания; если возрастает нагрузка, то
система не захлебнется запросами, т.к. есть backpressure.

Несмотря на все плюсы асинхронной обработки, она очень сложна в реализации. Вот краткий список основных трудностей,
связанных с реализацией такого подхода:

* клиент и сервер должны гарантировать доставку и успешную обработку сообщений;
* каждый запрос становится заявкой и должен иметь персистентное состояние, чтобы гарантировать нахождение системы всегда
  в детерминированном положении. такую систему сложно мониторить, т.к. недоступность или ошибка в системе может
  выливаться лишь в увеличении очереди;
* система не прозрачна с точки зрения бизнес-процессов, т.к. синхронные процессы разрываются на асинхронные независимые
  этапы. Ее очень сложно проектировать и расширять.

#### Виды асинхронной обработки

Часто помимо обработки самого запроса требуется сделать много дополнительных вещей, связанных с самим запросом лишь
косвенно: запись статистики, инкременты счетчиков. Эти операции можно выполнить на этапе постобработки после того, как
ответ был отдан пользователю. Однако иногда описанного выше подхода с постобработкой данных недостаточно. Действия,
которые надо совершить с ними, могут занимать слишком много времени, а ресурсы веб-сервера не безграничные. В таком
случае помогает следующий архитектурный паттерн — сохраните данные в некое промежуточное хранилище, а затем обработайте
их с помощью отдельного асинхронного процесса. То есть данные собираются сейчас, а обрабатываются тогда, когда будет
удобно.

Примеры:

* Отложенная обработка: отправка письма о завершении регистрации в фоновом потоке.
* Фоновый процесс: отправка предагегированных данных в сервис статистики раз в час.

### Заявка, жизненный цикл заявки

Ввиду того, что в рамках распределенных систем мы взаимодействуем с другими системами, находящимися вне нашего контроля,
при проектировании следует предусматривать обработку отказов и некорректных состояний.

Введем понятие заявки как некоторой единицы работы, передаваемой для выполнения ко внешней системе. С каждой заявкой
обычно ассоциируется некоторый уникальный ID, служащий для ее идентификации как в системе-инициаторе, так и во внешней
системе. Это может быть либо один и тот же идентификатор, сообщаемый системе-инициатору заявки после принятия заявки на
обработку. Но это могут быть и два разных идентификатора: один создаётся в системе, обрабатывающей заявку, а другой
создается в системе обработчике. Наличие в пришедшем сообщении на создание заявки идентификатора заявки, назначенного
удалённой системой, крайне полезно, поскольку позволяет отбросить дубликаты таких сообщений.

Т.к. заявка является единицей работы, у нее должны быть начальное и конечные состояния. Под обработкой заявки
подразумеваем переход заявки из начального состояние в какое-то конечное (
успешное/неуспешное). После попадания в конечное состояние заявка уже не меняет свое состояние, а находится в некотором
архиве завершенных заявок.

Кроме основного состояния, заявка обычно характеризуется множеством параметров, которые можно разбить на две группы.

* К первой относятся полученные извне параметры заявки, появляющимися в момент её создания из параметров сообщения, и,
  может быть, меняемые в дальнейшем. Эту группу мы будем (условно) называть параметрами запроса.
* Ко второй группе относятся добавленные в ходе выполнения заявки параметры, связанные с процессом обработки заявки. Это
  множество может меняться в процессе жизни заявки. Эту группу мы будем (условно) называть параметрами обработки заявки.

Очевидно, что создание протокола, допускающего произвольное изменение параметров запроса извне может быть довольно
сложным, особенно если речь идёт о запросе дополнительных ресурсов или частичном уменьшении требуемых ресурсов (
представим, что в ходе обработки заявки мы закупаем недостающий товар у третьего лица). Поэтому в реальных системах мы
часто видим ситуацию, когда единственным допустимым изменением со стороны является запрос на отмену заявки, а для
добавление ресурсов нужно послать запрос на создание новой заявки.

Естественным представлением жизненного цикла заявки является детерминированный конечный автомат с выходом. Формально
было бы верно считать множеством состояний этого автомата подмножество декартова произведения множества состояний заявки
и всех множеств значений параметров обработки заявки. Однако практическая полезность у такого автомата может быть только
при использовании формальных методов его исследования, для программиста же весьма сомнительна полезность автомата, где
каждая из N попыток повтора опроса M идентичных (с точки зрения уровня протокола) систем представлена отдельным
состоянием. В силу этого, при проектировании используется сокращённый вид автомата, где явно отображаются только
основные состояния заявки, в то время как состояние автомата определяется, формально, как подмножество декартово
произведения состояния и параметров. Функция перехода будет отображать состояние заявки, параметры заявки и сообщение (
со всеми его параметрами) в новое состояние заявки и в новые параметры заявки (например, число неудавшихся попыток
увеличилось на единицу). Состояния автомата соответствуют моментам времени, в котором он ожидает получения сообщений (от
внешних систем, подтверждения от человека и т.д.).

В соответствии с данным определением РС, автомат должен отвечать как минимум двум требованиям:

* при получении любого сообщения, на появление которого не удалось придумать сколь-нибудь разумную реакцию в данном
  состоянии, автомат либо остается в данном состоянии (и добавляет запись в журнал для дальнейшего разбора), либо
  переходит в конечное состояние;
* автомат должен попадать в одно из конечных состояний за конечный промежуток времени при любой входной цепочке внешних
  событий.

Таким образом, при каждой смене состояния должен запускаться (или продолжать работать) таймер, который пришлет сообщение
о таймауте, которое должно быть обработано автоматом.

Отметим, что успешная отправка сообщения в РС не означает, что сообщение принято к исполнению, поэтому нет оснований
утверждать, что мы когда-нибудь получим ответ. Поэтому, в силу требования надежности, использование таймеров необходимо
всегда.

## Примеры

Для демонстрации развернем кластер из 2 брокеров Kafka и Zookeeper.

```shell
$ git clone git@github.com:Romanow/ansible-kafka.git
$ cd ansible-kafka
```

#### Локальный кластер

```shell
$ cd vagrant
$ vagrant up
$ vagrant status
Current machine states:

zookeeper                 running (virtualbox)
broker1                   running (virtualbox)
broker2                   running (virtualbox)

$ sudo tee -a /etc/hosts > /dev/null << EOT
192.168.51.10     zookeeper.romanow-alex.ru
192.168.51.11     broker-1.romanow-alex.ru
192.168.51.12     broker-2.romanow-alex.ru
EOT

$ ansible-playbook -i inventories/local/static.yml --vault-password-file=.vault_pass kafka.yml -v

PLAY RECAP ***********************************************************************************************************************
192.168.51.10              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
192.168.51.11              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
192.168.51.12              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

#### Кластер в DigitalOcean

```shell
$ cd terraform
$ terraform apply
Apply complete! Resources: 6 added, 0 changed, 0 destroyed.

Outputs:

instance_ip_addr = [
  "161.35.86.193",
  "161.35.86.247",
  "161.35.86.216",
]

$ export DO_API_TOKEN=<DigitalOcean Token>
$ ansible-playbook -i inventories/digitalocean/digital_ocean.py --vault-password-file=.vault_pass kafka.yml -v

PLAY RECAP ***********************************************************************************************************************
161.35.86.193              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
161.35.86.216              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
161.35.86.247              : ok=12   changed=9    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

```shell
$ wget https://archive.apache.org/dist/kafka/2.8.1/kafka_2.12-2.8.1.tgz -O kafka.tgz
$ mkdir kafka && tar zxvf kafka.tgz -C kafka --strip-components 1
$ cd kafka
$ ./kafka-topics.sh --zookeeper zookeeper.romanow-alex.ru:2181 --create --replication-factor 1 --partitions 1 --topic TestTopic
Created topic TestTopic.
$ ./kafka-topics.sh --list --zookeeper zookeeper.romanow-alex.ru:2181
TestTopic
# Из разных терминалов
$ ./kafka-console-producer.sh --bootstrap-server broker-1.romanow-alex.ru:9092,broker-2.romanow-alex.ru:9092 --topic TestTopic
>Hello, world
>Welcome to microservices
>Kafka is the best broker!

$ ./kafka-console-consumer.sh --bootstrap-server broker-1.romanow-alex.ru:9092,broker-2.romanow-alex.ru:9092 --topic TestTopic
Hello, world
Welcome to microservices
Kafka is the best broker!
^CProcessed a total of 3 messages
```

## Литература

1. [Backpressure explained — the resisted flow of data through software](https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7)
1. [Нужен ли нам JMS в мире современных Java-технологий](https://www.youtube.com/watch?v=ExjPxDxkmFo)
1. [Оркестрируемая сага или как построить бизнес-транзакции в сервисах с паттерном database per service](https://habr.com/ru/company/oleg-bunin/blog/418235/)
1. [Microservices — When to React Vs. Orchestrate](https://medium.com/capital-one-tech/microservices-when-to-react-vs-orchestrate-c6b18308a14c)